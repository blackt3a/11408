## 线性表的定义和基本操作

### 线性表的定义

#线性表的定义

线性表是具有相同数据结构类型的$N（N \ge 0）$个数据元素的==有限序列==，是一种单纯的==逻辑==结构

特点：

- 个数==有限==
- 元素类型都==相同==
- 逻辑上的==顺序==性（重要）
- 不用考虑元素具体是什么内容（==抽象==性）

注意：

​	线性表不等同于==数组==（数组），线性表是一种==逻辑==结构。

​	而顺序表和链表都是指==存储==结构，都可以==实现==线性表不要搞混了。

​	顺序性也不是指==大小排序==，是相对顺序。

操作：

```C++
InitList(&L)
Length(L)
LocateElem(L,e)
GetElem(L,i)
ListInsert(&L,i,e)
ListDelete(&L,i,&e)
PrintList(L)
Empty(L)
DestoryList(&L)
//以上函数在涉及修改数据时使用的是引用（&），没有涉及到修改时使用的是值传递
```





## 线性表的顺序表示

### 顺序表的定义

线性表的==顺序存储==称为顺序表。在物理地址上依次==-相邻==。逻辑顺序和物理顺序==相同==。

线性表中的任意元素都可以==随机存取==（配合链表来理解，链表只能从头开始遍历），随机存取是通过线性表的==首地址==和==偏移==实现。

线性表的优点：

- 存储密度高，每个结点只存储数据元素（相比于链表，不用存放指针，空间利用率高）
- 实现随机访问，在O(1)时间复杂度内完成。

线性表的缺点：

- 存储需要==大量连续==的空间，插入和删除也需要==移动==大量元素。



### 顺序表基本操作的实现

#### 插入操作

```c++
bool ListInsert(SqList &L,int i,ElemType e){
	if(i<1 || i>L.length+1)
		return false;
	if(L.length>=MaxSize)
		return false;
	for(int j=L.length;j>=i;j--)
		L.data[j]=L.data[j-1];
	L.data[i-1] =e;
	L.length++;
	return true;
}
```

顺序表插入算的时间复杂度为$O(n)$

#### 删除操作

```c++
bool ListDele(SqList &L,int i,Elemtype &e){
	if(i<1 || i>L.length)	//安全检查
		return false;
	e = L.data[i-1];		//记录被删除元素
	for(int j=i;j<L.length;j++);	//被删除元素后的元素依次前移
		L.data[j-1]=L.data[j];
	L.length--;				
	return true;
}
```

时间复杂度：最好是$O(1)$最坏是$O(n)$，平均下来还是$O(n)$

插入和删除操作的时间花费大部分是元素的==移动==上，所以涉及随机存取的可以优先使用顺序表，设计插入和删除的，可以使用链表。





## 线性表的链式表示

#线性表的链式表示

顺序表虽然可以实现随机存储，但是==插入==和==删除==操作却需要==移动==大量元素。于是有了链式存储，不需要==大量连续==的存储单元（不要求逻辑相邻的元素物理也相邻）。通过==指针==链接。插入和删除不需要移动元素，只需要==修改==指针。但也==失去==了随机存储的优点。

### 单链表的定义

| data | next |
| ---- | ---- |



```c++
typedef struct LNode{
	ElemType data;		//数据域
	struct LNode *next;	//指针域
}LNode, *LinkList;
```



关于头结点和头指针：

- 头指针

  指向==第一个==结点的指针，每一链表==都有==头指针，它决定了链表==开始==的位置

- 头结点

  链表的第一个结点（==可以不用==记录数据，单纯站位用，也可以用来记录链表==长度==）

  头结点的好处：

  - 可以让第一个存储数据的结点在操作上不用==特殊处理==，统一了对所有==存储==数据结点的处理。
  - 不管链表是否为空，头指针==都将==指向头结点，==统一==了对空表和非空表的处理。



单链表的优点：

- 单链表可以结局顺序表需要大量连续存储单元的缺点，可以实现离散存储

单链表的缺点：

- 每个结点都需要存储next指针，空间利用率低。



### 单链表基本操作的实现

单链表的操作有：

- 初始化链表

  - 头插法

    实现：

    ​	每生成一个新结点，将新结点==直接==插入到当前链表的==表头==

    特点：

    ​	采用头插法，遍历结点时，最后插入的结点先遍历，输入和输出顺序==相反==（有点像栈）

    ​	==单==次插入时间复杂度为$O(1)$，当结点为$n$，==总==的时间复杂度为$O(n)$

    

  - 尾插法

    头插法的输入次序和输出次序不同，于是就有尾插法，使输入和输出顺序==相同==。

    实现：

    ​	每生成一个新结点，需要先==遍历==到链表尾部，然后==再==将新结点插入到链==表尾==。

    ​	如果额外有一个指针，可以==记录==链表的尾指针，那么就==不用==每次插入都遍历到尾部。

    

- 按序号查找结点

  从第一个存储数据的结点出发，顺着next逐个搜索，每找到一个结点，就给==计数器==+1，直到找到最后一个结点（其next域为null）

- 按值查找结点

  顺着链表依次遍历，直到找到给定数据

- 插入结点（一般采用==前插==法）

  > - 前插法
  >
  >   需要找到前面一个结点==配合==，插在其后面。如需在第$i$个结点插入时，需找到第$i-1$个结点，并插在其后面。
  >
  >   ![_407743453__8d5c01c7e9056eeaf6a443d8b5623ac5_1585209821_Screenshot_20230730_100812_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_407743453__8d5c01c7e9056eeaf6a443d8b5623ac5_1585209821_Screenshot_20230730_100812_com.jideos_0_wifi_0.jpg)
  >
  >   需要==注意==的是，执行插入时，对结点的操作是有顺序要求的，一般先处理后驱，再处理前驱才能保证指针不丢失
  
  
  
   - 后插法(不用)
  
     当插入第$i$个结点时，插在第$i$个结点后面。



> - 删除结点
>
>   只需将第$i$个结点的==后驱==指针写入$i$前驱的next域
>
> ![_742392829__e3ba7e72c20e129b20ff32a70593e30c_1162293471_Screenshot_20230730_100737_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_742392829__e3ba7e72c20e129b20ff32a70593e30c_1162293471_Screenshot_20230730_100737_com.jideos_0_wifi_0.jpg)





- 求表长

  遍历链表，同时==计数器+1==，时间复杂度为$O(n)$



注意：

- 当使用带头结点的循环单链表存储时，头指针为`head`，线性表为`0`或`1`，==都==有可能使`head->next->next==head`
- 在无序数据转为有序链表时，==还==需要进行排序。
- 遇到不对劲的选项，最好是确认下。







## 双链表

#双链表

因为单链表只有一个指向后驱的指针。在遍历时，只能==从头到尾==依次遍历。

为了解决这个问题，引入了双链表

| pre  | data | next |
| ---- | ---- | ---- |

```c++
typedef struct DNode{
	ElemType data;					//数据域
	struct DNode *prior, *next;		//前后驱
}DNode, *DLinklist;					//结点，链表类型
```





### 双链表的插入

#双链表的插入

> 双链表的插入也是有==顺序要求==的，但对前后结点无要求，只要==相邻==就行
>
> ![_322675211__df6863f206dd0395cf241b87c0ced0ca_1997529440_Screenshot_20230730_100914_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_322675211__df6863f206dd0395cf241b87c0ced0ca_1997529440_Screenshot_20230730_100914_com.jideos_0_wifi_0.jpg)
>
> 如图双链表插入原则的关键是第:four:步![_-405532966__90cb443cd05101fda233dee605ef98dd_-1167121939_Screenshot_20230730_105152_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_-405532966__90cb443cd05101fda233dee605ef98dd_-1167121939_Screenshot_20230730_105152_com.jideos_0_wifi_0.jpg)











### 双链表的删除

```c++
//若删除p的后继结点q
p->next = q->next;  
p->next->pre = p;
free(q)
```

![_-1239949280__77a306578c074206786041861114278e_2068280190_Screenshot_20230730_100846_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_-1239949280__77a306578c074206786041861114278e_2068280190_Screenshot_20230730_100846_com.jideos_0_wifi_0.jpg)

==不要求==顺序







## 循环链表

### 循环单链表

循环链表的最后一个结点，不指向NULL,指向==头结点==。

链表为空是，头结点==指向自己==![_1842131515__893252f893a871574efe99ac19f77a2a_974870747_Screenshot_20230730_105903_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_1842131515__893252f893a871574efe99ac19f77a2a_974870747_Screenshot_20230730_105903_com.jideos_0_wifi_0.jpg)

- 没有了==表尾==，不用再单独处理。

- 任何位置插入和删除都是等价的。

- 可以从任何结点开始遍历

  > 如果不设头指针，而是用尾指针，操作效率会==更高==。设头指针时，在队尾插入需$O(n)$时间复杂度。设置尾指针r时，`r->next`就是头指针，此时对头尾的插入都是$O(n)$时间复杂度。相当于针对性的对==头尾插入==进行了优化。







### 循环双链表

链表为空时，头结点的`next`和`pre`指针都指向==头结点==

![_881215053__9e3f4dc6ce920f58d5247baec6d4517b_840857241_Screenshot_20230730_105923_com.jideos_0_wifi_0](./pictures/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/_881215053__9e3f4dc6ce920f58d5247baec6d4517b_840857241_Screenshot_20230730_105923_com.jideos_0_wifi_0.jpg)

- 无==头尾==之分

- 无==前后==之分





## 静态链表

静态链表就是借助==数组==（所以，也需要一==大块连续==的空间）来描述线性表的链式存储结构。

| data | next |
| ---- | ---- |

```C++
#define MaxSize 50
typedef struct{
	ElemType data		//数据域
	int next			//下标
} SLinkList[MaxSize]
```

与单链表不一样的是，静态链表结点中的next存储的是==下一个结点==在数组中的==下标==（index）。

链表尾部结点的`next`存储的是==-1==，静态链表的插入，删除操作与动态链表相同（只需要修改指针）。虽没有单链表方便，但对于一些==不支持==指针的语言(Basic)，是一个巧妙的设计。











## 顺序表和链表的比较

- 存取(读写)方式方面

  顺序表：随机存取，顺序存取

  链表：顺序存取（从头开始遍历）

- 逻辑结构和物理结构

  顺序表：逻辑相邻的元素，物理存储位置也相邻。

  链表：逻辑相邻的元素，物理存储位置==不一定==相邻。

- 查找，插入，删除操作

  ==按值查找==时，两个时间复杂度相同$O(n)$.

  ==按序号查找==时，顺序表支持随机访问，时间复杂度为$O(1)$,链表的时间复杂度为$O(n)$

  顺序表的==删除和插入==不如链表效率高

  顺序表的==空间利用率==比链表高。

- 空间分配

  - 基于存储的考虑

    ==难以估计==数据规模不适宜顺序存储(难找足够大的连续空间)。单利用率小于$1$

  - 基于运算的考虑

    若经常按序号访问(随机访问)数据元素,优先==顺序表==。

    若经常进行插入，删除操作时，优先==链表==。

  - 基于环境的考虑

    顺序表通常都简单些

    链表相对都复杂些。



