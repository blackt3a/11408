## 线性表的定义和基本操作

### 线性表的定义

#线性表的定义

线性表是具有相同数据结构类型的$N（N \ge 0）$个数据元素的==有限序列==，是一种单纯的==逻辑==结构

特点：

- 个数==有限==
- 元素类型都==相同==
- 逻辑上的==顺序==性（重要）
- 不用考虑元素具体是什么内容（==抽象==性）

注意：

​	线性表不等同于==数组==（数组），线性表是一种==逻辑==结构。

​	而顺序表和链表都是指==存储==结构，都可以==实现==线性表不要搞混了。

​	顺序性也不是指==大小排序==，是相对顺序。

操作：

```C++
InitList(&L)
Length(L)
LocateElem(L,e)
GetElem(L,i)
ListInsert(&L,i,e)
ListDelete(&L,i,&e)
PrintList(L)
Empty(L)
DestoryList(&L)
//以上函数在涉及修改数据时使用的是引用（&），没有涉及到修改时使用的是值传递
```





## 线性表的顺序表示

### 顺序表的定义

线性表的==顺序存储==称为顺序表。在物理地址上依次==-相邻==。逻辑顺序和物理顺序==相同==。

线性表中的任意元素都可以==随机存取==（配合链表来理解，链表只能从头开始遍历），随机存取是通过线性表的==首地址==和==偏移==实现。

线性表的优点：

- 存储密度高，每个结点只存储数据元素（相比于链表，不用存放指针，空间利用率高）
- 实现随机访问，在O(1)时间复杂度内完成。

线性表的缺点：

- 存储需要==大量连续==的空间，插入和删除也需要==移动==大量元素。



### 顺序表基本操作的实现

#### 插入操作

```c++
bool ListInsert(SqList &L,int i,ElemType e){
	if(i<1 || i>L.length+1)
		return false;
	if(L.length>=MaxSize)
		return false;
	for(int j=L.length;j>=i;j--)
		L.data[j]=L.data[j-1];
	L.data[i-1] =e;
	L.length++;
	return true;
}
```

顺序表插入算的时间复杂度为$O(n)$

#### 删除操作

```c++
bool ListDele(SqList &L,int i,Elemtype &e){
	if(i<1 || i>L.length)	//安全检查
		return false;
	e = L.data[i-1];		//记录被删除元素
	for(int j=i;j<L.length;j++);	//被删除元素后的元素依次前移
		L.data[j-1]=L.data[j];
	L.length--;				
	return true;
}
```

时间复杂度：最好是$O(1)$最坏是$O(n)$，平均下来还是$O(n)$

插入和删除操作的时间花费大部分是元素的==移动==上，所以涉及随机存取的可以优先使用顺序表，设计插入和删除的，可以使用链表。





## 线性表的链式表示

#线性表的链式表示

顺序表虽然可以实现随机存储，但是==插入==和==删除==操作却需要==移动==大量元素。于是有了链式存储，不需要==大量连续==的存储单元（不要求逻辑相邻的元素物理也相邻）。通过==指针==链接。插入和删除不需要移动元素，只需要==修改==指针。但也==失去==了随机存储的优点。

### 单链表的定义

| data | next |
| ---- | ---- |



```c++
typedef struct LNode{
	ElemType data;		//数据域
	struct LNode *next;	//指针域
}LNode, *LinkList;
```



关于头结点和头指针：

- 头指针

  指向==第一个==结点的指针，每一链表==都有==头指针，它决定了链表==开始==的位置

- 头结点

  链表的第一个结点（==可以不用==记录数据，单纯站位用，也可以用来记录链表==长度==）

  头结点的好处：

  - 可以让第一个存储数据的结点在操作上不用==特殊处理==，统一了对所有==存储==数据结点的处理。
  - 不管链表是否为空，头指针==都将==指向头结点，==统一==了对空表和非空表的处理。



单链表的优点：

- 单链表可以结局顺序表需要大量连续存储单元的缺点，可以实现离散存储

单链表的缺点：

- 每个结点都需要存储next指针，空间利用率低。



### 单链表基本操作的实现

单链表的操作有：

- 初始化链表

  - 头插法

    实现：

    ​	每生成一个新结点，将新结点==直接==插入到当前链表的==表头==

    特点：

    ​	采用头插法，遍历结点时，最后插入的结点先遍历，输入和输出顺序==相反==（有点像栈）

    ​	==单==次插入时间复杂度为$O(1)$，当结点为$n$，==总==的时间复杂度为$O(n)$

    

  - 尾插法

    头插法的输入次序和输出次序不同，于是就有尾插法，使输入和输出顺序==相同==。

    实现：

    ​	每生成一个新结点，需要先==遍历==到链表尾部，然后==再==将新结点插入到链==表尾==。

    ​	如果额外有一个指针，可以==记录==链表的尾指针，那么就==不用==每次插入都遍历到尾部。

    

- 按序号查找结点

  从第一个存储数据的结点出发，顺着next逐个搜索，每找到一个结点，就给==计数器==+1，直到找到最后一个结点（其next域为null）

- 按值查找结点

  顺着链表依次遍历，直到找到给定数据

- 插入结点

- 删除结点

- 求表长

#### 

