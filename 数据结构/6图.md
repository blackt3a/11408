## 6.1图的基本概念

图的算法主要是深度优先和广度优先

图的存储主要是邻接矩阵，邻接表，邻接多重表和十字链表

存储结构之间的转化

相关的遍历，排序

### 6.1.1图的定义

图由==边==和==顶点==组合而成。

注意线性表==可以是==空表，图==不能==是空图

- #### 有向图

结点间的边有方向

- #### 无向图

结点间间的边没有方向

- #### 简单图，多重图

简单图::one:不存在重复边:two:不存在顶点到自身的边

- #### 完全图

  - 完全无向图

    每一个结点间都有(无向)边，共有$\frac{n(n-1)}{2}$条边

  - 完全有向图

    每一个结点间都有(有向)边，共有${n(n-1)}$条边

- #### 子图

  顶点是==子集==，边是==子集==的同时还==能==构成图

  注意，并非是子集就能构成子图，因为其构成的可能并不是图

- #### 连通，连通图和连通分量

  两点之间有路径存在(==不是==一定直接连通)即视作==连通==的。

  若图中任意两点都是连通的，则称其为==连通图==，否则是非连通图。

  无向图的极大连通子图称为==连通分量==(参考树的度概念)

  若有$n$个顶点的图有==少于==$n-1$个边，则其必为非连通图。

- #### 强连通图，强连通分量(有向图)

  若两个顶点间==两个==方向都有连通，则称其强连通。

  

  ==注意==：无向图中讨论连通性，有向图中讨论强连通性

  

- #### 生成树，生成森林

​	连通图的生成树是包含图中==全部顶点==的==极小连通图==

​	若有$n$个顶点，则有$n-1$条边，若少一条边则==非连通==，若在加一条边则形成==回路==

​	意义：用最少的边将所有结点连接起来，而且不构成回路



注意：==区别==极大连通子图和极小连通子图

:one:极大连通子图是==尽可能多==的顶点==尽可能多==的边(子图中最大的)

:two:极小连通子图是==最少==的边连接==所有==顶点



- #### 定点的度，入度和出度

  度=入度+出度

- #### 边的权和网

  如果每条边带有==权值==，则称其为==网==

- #### 稠密图和稀疏图

  边少的是稀疏图，边多的是稠密图，一般以$VlogV$做标准

- #### 路径，路径长和回路

  路径是一个顶点到另一个顶点的边

  路径的==边数==称为路径长度，没有路径则其长度为无穷

  若一个图有$n$个顶点，并且有$n-1$条边，则该图==一定==有环

- #### 简单路径，简单回路

  ==路径序列==中，顶点不重复出现的路径称为简单路径

  ==除==第一个和最后一个，顶点不重复出现的称为简单回路。

  

- #### 距离

  从一个顶点到另一个顶点的==最短路径==，称为顶点间距离，若不存在路径则其距离==无穷==。

- #### 有向树

  一个顶点的入度为`0`,其余顶点的入度均为`1`的有向图，称为有向树。





## 6.2图的存储及基本操作

### 6.2.1邻接矩阵法

用一个==二维==数组存储图中边的信息，存储顶点之间的邻接关系的二维数组为==邻接矩阵==

无向图中

`A[1][2]`和`A[2][1]`一样代表结点`1`和结点`2`间连通。

有向图中

`A[1][2]`和`A[2][1]`一样代表结点`1`和结点`2`==不同方向==间连通。

```c++
#define MaxVertexNum
typedef char VertexType;
typedef int EdgeType;
typedef struct{
	VertexType Vex[MaxVertexNum];
	Edgetype Edge[MaxVertexNum][MaxVertexNum];
	int vexnum,arcnum;
}
```

==注意==：

- 简单应用中，可直接用二维数组作为图的邻接矩阵
- 可以用`0`或`1`表示相关的边是否存在
- 无向图的邻接矩阵是==对称==矩阵，可以使用压缩存储。
- 邻接矩阵的空间复杂度是$O(n)$，其中$n$为图的顶点数

==特点==：

- 无向图是一个对称矩阵，只需要存储上(下)三角的矩阵
- 矩阵==每行==的非零元素刚好是该结点的出度，==每列==的非零元素是该点的入度。
- 用邻接矩阵==容易确认==两顶点间是否有边，但数边的==总数==会不方便
- 稠密图适合邻接矩阵
- 如果图G的邻接矩阵是`A`，$A^{n}$的元素$A^{n}[i][j]$等于由顶点$i$到顶点$j$的长度为$n$的==数目==(离散数学证)





### 6.2.2邻接表法

因为邻接矩阵会存储稀疏图的时候会浪费空间，所以有了==邻接表法==，结合了==顺序==存储和==链式==存储方法，每个节点的链表表示依附该结点的边的集合。

实现：

- 将所有结点==顺序排列==在数组
- 为==每==一个顶点建立一个单链表

所以，有两个表，链表是==边==的集合，顺序表是==顶点==的集合。

```c++
#define MaxVertexNum 100
typedef struct ArcNode{
	int adjvex;
	struct ArcNode *next;
}ArcNode;

typedef struct VNode{
	VertexType data;
	ArcNdoe *first;
}VNode,AdjList[MaxVertexNum];

typedef struct{
	AdjList vertices;
	int vexnum,arcnum;
}
```

特点：

- 若为无向图，存储空间为$O（顶点数+2倍边数）$，若为有向数存储空间为$O（顶点数+边数）$
- 适合存储稀疏图，节省空间
- 邻接表中，给定一个顶点，很容易找到其所有边，时间花费为$O(n)$,但若确认某边是否存在，则效率很低。
- ==有向图==的邻接表中，计算==出度==很方便(链表的结点个数)，但计算==入度==需要遍历所有(虽然可以通过尝试采用==逆邻接表==解决)
- 图的邻接表并==不唯一==







### 6.2.3邻接多重表(无向图)

为了存储==无向图==，有了十字链表法的==pro版==

弧结点：

| ilvex | ilink | jvex | jlink | （info） |
| ----- | ----- | ---- | ----- | -------- |

顶点结点：

| data | fisrtedge |
| ---- | --------- |



### 6.2.4十字链表法(有向图)

为了解决邻接表存储有向图查找入度不方便的问题，有了十字链表法，可以==同时==存储入度和出度，也是结合了==顺序表==和==链表==相当于邻接表法的==pro plus版==

弧结点：

| tailvex | headvex | hlink | tlink | （info） |
| ------- | ------- | ----- | ----- | -------- |

顶点结点：

| data | fisrtin | fistout |
| ---- | ------- | ------- |





### 6.2.5图的基本操作



## 6.3图的遍历

### 6.3.1广度优先搜索

### 6.3.2深度优先搜索

### 6.3.3图的遍历与图的连通性



## 6.4图的应用

### 6.4.1最小生成树

### 6.4.2最短路径

### 6.4.3有向无环图描述表达方式

### 6.4.4拓扑排序

### 6.4.5关键路径



