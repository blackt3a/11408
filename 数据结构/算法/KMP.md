### 先看看朴素算法

朴素算法就主打一个朴素，简单。利用暴力遍历思想，对比了主串中==所有==的==等长==子串。

但效率低。

#串朴素算法 

```c

int Index(SString S,SString T){
	int i=1,j=1;						//从下标1开始，T[1],S[1]开始
	while(i<=S.length && j <=T.length){  //安全检查，须在S和T长度范围内
		if(S.ch[i]==T.ch[j]){
			++i;	//如果字符相同，则准备比较下一个字符
			++j;	
		}else{		
			i =i-j+2;	//如果比较到某个字符不同，减去偏移，表示这个字串不匹配
						
			j=1;		//模式串又从头开始。
		}
	}
	if(j>T.length) 		//模式串遍历完，返回在主串中的偏移
		return i-T.length;
	else
		return 0;		//模式串比主串长
}
```

若主串和模式串的长度分别为N,M
则时间复杂度为==O(NM)==



### KMP算法

#KMP算法

关键词：最长共同前后缀，回退

KMP是串的匹配算法，解决 #串朴素算法 的一些缺陷。

朴素算法中，一旦查找失败，主串和模式串将一起回退。KMP算法尝试将之前失败但获得的信息利用起来，减少回退次数,不用一失败就从头开始匹配。提高效率。在KMP算法中，时间复杂度为==O (M+N)==

核心思想：利用已知信息（模式串），避免无用的回退。

实现条件：字符串的前缀，后缀，和部分匹配值（PM）

- 我们可以利用模式串的信息，推测主串中==已经参与==匹配的字符信息。
- 如果此时模式串中的某一字串还有相同的前后缀，那主串已经参与匹配的字符也必有==相同==的前后缀（主串利用后缀，模式串利用前缀）

于是，我们有了==最长相同前后缀==这一概念，假设它的字符长为P（注意，是最长）



如果不用全部回退，那么回退多少呢？或者说，我们可以跳过多少不用匹配？

答：我们可以跳过P个字符，这P个字符不用匹配，因为我们模式串的==前缀==和已参与比较部分==后缀==相同。





> 每当子串匹配失败的时候，主串的指针==不用==回退，而模式串的指针会根据`next[n]`中相应字符对应的==值==决定回退到的==位置==重新进行比较。如此，算法的关键就在与next[n]的计算。

`next[n]`的求解：

先从左到右==依次==求得模式串中各字串的最大相同前后缀表

例如：

| 编号 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| S    | a    | b    | c    | a    | c    |
| PM   | 0    | 0    | 0    | 1    | 0    |

将PM表中的(仅)PM值右移(空缺的用`-1`补)，然后一齐`+1`，得`next[n]`

例如：



| 编号 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| S    | a    | b    | c    | a    | c    |
| next | 0    | 1    | 1    | 1    | 2    |

从这里可以看出`next[n]`的特征，即前两个数字必定是`0`和`1`。





对于计算机代码而言，可以使用递归实现(相对的，手算就麻烦了很多)

#### 代码实现

```c++
void get_next(SString T,int next[]){
	int i=1,j=0;
	next[1];
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j])
		++i;
		++j;
		next[i]=j;
		else
			j=next[j];
	}
}



int Index_KMP(SSTring S,SString T,int next[]){
    int i=1,j=1
    while(i<=S.length && j<=T.length){
        if(j==0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        }
        else
            j=next[j];
    }
    if(j>T.length)
        return i-T.length;
    else
        return 0;
        
}

```



#### KMP的优化

这里依然会有一个小问题

例如：

当`next`如下

| 主串    | a    | a    | a    | b    | a    | a    | a    | a    | b    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式    | a    | a    | a    | a    | b    |      |      |      |      |
| j       | 1    | 2    | 3    | 4    | 5    |      |      |      |      |
| next[j] | 0    | 1    | 2    | 3    | 4    |      |      |      |      |

1. 当匹配到第`4`个字符时，不匹配，模式串先回退到`j=next[4]=3`。
2. 然后匹配到第`3`个字符时，不匹配，模式串先回退到`j=next[3]=2`。
3. 然后匹配到第`2`个字符时，不匹配，模式串先回退到`j=next[2]=1`。
4. 然后匹配到第`1`个字符时，不匹配，模式串先回退到`j=next[3]=0`。

可以发现以上步骤是可以==递归==的，且没有必要进行。那么我们就可以针对`next[n]`进行针对性优化(采用递归)。

得到：

| 主串       | a    | a    | a    | b    | a    | a    | a    | a    | b    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式       | a    | a    | a    | a    | b    |      |      |      |      |
| j          | 1    | 2    | 3    | 4    | 5    |      |      |      |      |
| next[j]    | 0    | 1    | 2    | 3    | 4    |      |      |      |      |
| nextval[j] | 0    | 0    | 0    | 0    | 4    |      |      |      |      |





`KMP`的优化，主要是在与`next[n]`的优化上,

```c++
void get_nextval(SString T,int nextval[]){
	int i=1,j=0;
	nextval[1]=0;
	while(i<T.length){
		if(j==0 || T.ch[i] ){
			++i;
			++j;
			if(T.ch[i] != T.ch[j])
				nextval[i]=j;
			else{
				nextval[i]=nextval[j];
			}
		else{
			j=nextval[j];
		}	
		
				
		}
	}
}
```





### 



### 手算

`next[1]=0`

`next[2]=1`

在不匹配的位置前,画一根分界线。模式串一步一步后退，直到分界线之前“能对上”或完全跨过界，此时`j`指向哪，`next`值就为多少
