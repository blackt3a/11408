### 先看看朴素算法

朴素算法就主打一个朴素，简单。利用暴力遍历思想，对比了主串中==所有==的==等长==子串。

但效率低。

#串朴素算法 

```c

int Index(SString S,SString T){
	int i=1,j=1;						//从下标1开始，T[1],S[1]开始
	while(i<=S.length && j <=T.length){  //安全检查，须在S和T长度范围内
		if(S.ch[i]==T.ch[j]){
			++i;	//如果字符相同，则准备比较下一个字符
			++j;	
		}else{		
			i =i-j+2;	//如果比较到某个字符不同，减去偏移，表示这个字串不匹配
						
			j=1;		//模式串又从头开始。
		}
	}
	if(j>T.length) 		//模式串遍历完，返回在主串中的偏移
		return i-T.length;
	else
		return 0;		//模式串比主串长
}
```

若主串和模式串的长度分别为N,M
则时间复杂度为==O(NM)==





KMP是串的匹配算法，解决 #串朴素算法 的一些缺陷。

朴素算法中，一旦查找失败，主串和模式串将一起回退。KMP算法尝试将之前失败但获得的信息利用起来，减少回退次数,不用一失败就从头开始匹配。提高效率。在KMP算法中，时间复杂度为==O (M+N)==

核心思想：利用已知信息（模式串），避免无用的回退。

实现条件：字符串的前缀，后缀，和部分匹配值（PM）

- 我们可以利用模式串的信息，推测主串中==已经参与==匹配的字符信息。
- 如果此时模式串中的某一字串还有相同的前后缀，那主串已经参与匹配的字符也必有==相同==的前后缀（主串利用后缀，模式串利用前缀）

于是，我们有了==最长相同前后缀==这一概念，假设它的字符长为P（注意，是最长）



如果不用全部回退，那么回退多少呢？或者说，我们可以跳过多少不用匹配？

答：我们可以跳过P个字符，这P个字符不用匹配，因为我们模式串的==前缀==和已参与比较部分==后缀==相同。

