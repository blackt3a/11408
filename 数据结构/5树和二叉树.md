## 树的基本概念

### 树的定义

度为$m$的树即有$m$个结点

$m$叉树可以无结点



### 基本术语

结点的度

叶节点

层次

深度

高度

有序树和无序树

路径和路径长度



### 树的性质

- 树的结点数等于所有结点的==度数和加1==
- 度为$m$的树第$i$层最多有$m^{i-1}个结点$（==等比数列==）

- 高度为$h$的$m$叉树最多有$(m^{h}-1/(m-1)$个结点 (==等比数列==)
- 具有$n$个结点的$m$叉树的最小高度为「$log_m(n(m-1)+1)$」（==等比数列==）
- 等比数列$\frac{a(1-r^n)}{1-r}$



树中叶结点的计算方法：

设树中度为$i(i=0,1,2,3,4)$的结点数分别为$n_i$,树中总结点树数为$n$，$n$等于==度数和加一==。即$n=1+n_1+2n_2+3n_3+4n_4=n_0+n_1+n_2+n_3+n_4$

$n_0=（1+n_1+2n_2+3n_3+4n_4）-（n_1+n_2+n_3+n_4)$









## 二叉树的概念

#### 二叉树的定义

二叉树是特殊的树，每个结点最多两颗子树(有左右之分，不能颠倒)

==二叉树==与==度为2==的树的==区别==：

- 度为2的树至少三个结点，二叉树==可以为空==
- 度为2的树结点可以无序，二叉树的结点==有序==



#### 几个特殊的二叉树

1. 满二叉树

   除叶结点外，所有结点的度数==都为2==

2. 完全二叉树(最==复杂==，以顺序结构的视角出发，可以不浪费空间)

   当且仅当其每一个结点都与深度为$K$的满二叉树中编号从$1到n$一一对应时，称为完全二叉树。

   

   - 若$i\le$「n/2」,则$i$为分支结点，否则为叶结点
   - 若有度为1的结点，则只会有==一个==，该结点==只有左结点==，没有右结点
   - 完全二叉树可以根据$i$结点，推测出双亲结点和子结点
     - 查找双亲结点，当$i>1$，双亲结点的编号为「$i/2$」
       - 当$i$为==偶数==，双亲结点为$i/2$，且$i$为==左孩子==
       - 当$i$为==奇数==，双亲结点为$(i-1)/2$，且$i$为==右孩子==
     - 查找子结点
       - 当$2i\le n$时，结点$i$的==左孩子为$2i$==，否则无左孩子
       - 当$2i+1\le n$时，结点$i$的==左孩子为$2i+1$==，否则无右孩子

3. 二叉排序树

   左树上的关键字==小于==根结点，右树上的关键字==大于==根结点，且满足==递归==。

4. 平衡二叉树(搜索效率高)

   树上任意一个结点的左子树和右子树的==深度之差==不超过1

==注意==：当二叉树的度只有2和0时，结点最少的情况

<img src="./pictures/5%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/_-46679321__2dde1a912e0016f3162f3498ac095463_1951562707_Screenshot_20230803_164312_com.jideos_0_wifi_0.jpg" alt="_-46679321__2dde1a912e0016f3162f3498ac095463_1951562707_Screenshot_20230803_164312_com.jideos_0_wifi_0" style="zoom:50%;" />

### 二叉树的定义及其主要特征



### 二叉树的存储结构

1. 顺序存储

   完全二叉树和满二叉树存储比较合适，

2. 链式存储

   ```c++
   typedef struct BiTNode{
   	ELemType data;
   	struct BiTNode *lchild, *rchild;
   }BiTNode,*BiTree;
   ```

   引伸出三叉树





## 二叉树的遍历和线索二叉树

### 二叉树的遍历

- 前序编列

```c++
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);
		PreOrder(T->lchild);
		PreOrder(T->lchild);
	}
}

```



- 中序遍历

```c++
void InOrder(BiTree){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->lchild);
	}
}
```



- 后序遍历

```c++
void PostOrder(BiTree){
	if(T!=NUll){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```

- 递归算法和非递归算法的转换(需要借用==栈和循环==实现)

- 层次遍历(借助队列实现)

  在某结点出队时，将它的左右子结点入队。

```c++
void LevelOrder(BiTree){
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);
	while(!IsEmpty(Q)){
		DeQueue(Q,p);
		visit(p);
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);
		if(p->rchild!=NULL)
			EnQueue(Q,p->rchild);
	}
}
```



- 由遍历构造二叉树

  不论那种构造二叉树，都至少需要==两种==序列且其中一个必须是==中序==遍历。

  - 先序和中序
  - 后序和中序
  - 层序和中序







### 线索二叉树

#### 线索二叉树的基本概念

在传统的树结构中，很难找到某结点的==双亲结点==，由此引出线索二叉树。

因为含$n$个结点的二叉树，有$n+1$个空指针。这些空指针可以利用起来存储信息。

```c++
typedef struct ThreadNode{
	ELemtype data;
	struct ThreadNode *lchild, *rchild;
	int ltag, rtag;
}
```



#### 中序线索二叉树的构造

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱和后继只有在遍历时才能得到，因此线索化的==实质==就是遍历一次二叉树

#### 中序线索二叉树的遍历

- 求中序线索二叉树的中序序列下的第一个结点

```c++
threadNode *Firstnode(ThreadNode *p){
	while(p->ltag==0) p=p->lchild;  //最左下结点(不一定是叶结点)
	return p;
}

```

- 求中序线索二叉树中结点p在中序序列下的后继

```
ThreadNode *Nextnode(ThreadNode *p){
	if(p->rtag==0) return Firstnode(p->rchild);
	else return p->rchild;
}
```



#### 先序线索二叉树和后序线索二叉树

先序线索二叉树好像没啥特别的，但是后序线索二叉树因为需要找到跟结点的==右子树==，所以需要知道双亲结点，即需要带标志位的==三叉==链表



## 树，森林

### 树的存储结构

### 树，森林与二叉树的转换

### 树和森林的遍历



## 树与二叉树的应用

### 哈夫曼树和哈夫曼编码

### 并查集