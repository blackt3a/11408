## 树的基本概念

### 树的定义

度为$m$的树即有$m$个结点

$m$叉树可以无结点



### 基本术语

结点的度

叶节点

层次

深度

高度

有序树和无序树

路径和路径长度



### 树的性质

- 树的结点数等于所有结点的==度数和加1==
- 度为$m$的树第$i$层最多有$m^{i-1}个结点$（==等比数列==）

- 高度为$h$的$m$叉树最多有$(m^{h}-1/(m-1)$个结点 (==等比数列==)
- 具有$n$个结点的$m$叉树的最小高度为「$log_m(n(m-1)+1)$」（==等比数列==）
- 等比数列$\frac{a(1-r^n)}{1-r}$



树中叶结点的计算方法：

设树中度为$i(i=0,1,2,3,4)$的结点数分别为$n_i$,树中总结点树数为$n$，$n$等于==度数和加一==。即$n=1+n_1+2n_2+3n_3+4n_4=n_0+n_1+n_2+n_3+n_4$

$n_0=（1+n_1+2n_2+3n_3+4n_4）-（n_1+n_2+n_3+n_4)$









## 二叉树的概念

#### 二叉树的定义

二叉树是特殊的树，每个结点最多两颗子树(有左右之分，不能颠倒)

==二叉树==与==度为2==的树的==区别==：

- 度为2的树至少三个结点，二叉树==可以为空==
- 度为2的树结点可以无序，二叉树的结点==有序==



#### 几个特殊的二叉树

1. 满二叉树

   除叶结点外，所有结点的度数==都为2==

2. 完全二叉树(最==复杂==，以顺序结构的视角出发，可以不浪费空间)

   当且仅当其每一个结点都与深度为$K$的满二叉树中编号从$1到n$一一对应时，称为完全二叉树。存储时最好从数组array[1]开始，数组下标可以和结点下标对齐。

   

   - 若$i\le$「n/2」,则$i$为分支结点，否则为叶结点
   - 若有度为1的结点，则只会有==一个==，该结点==只有左结点==，没有右结点
   - 完全二叉树可以根据$i$结点，推测出双亲结点和子结点
     - 查找双亲结点，当$i>1$，双亲结点的编号为「$i/2$」
       - 当$i$为==偶数==，双亲结点为$i/2$，且$i$为==左孩子==
       - 当$i$为==奇数==，双亲结点为$(i-1)/2$，且$i$为==右孩子==
     - 查找子结点
       - 当$2i\le n$时，结点$i$的==左孩子为$2i$==，否则无左孩子
       - 当$2i+1\le n$时，结点$i$的==左孩子为$2i+1$==，否则无右孩子

3. 二叉排序树

   左树上的关键字==小于==根结点，右树上的关键字==大于==根结点，且满足==递归==。

4. 平衡二叉树(搜索效率高)

   树上任意一个结点的左子树和右子树的==深度之差==不超过1

==注意==：当二叉树的度只有2和0时，结点最少的情况

<img src="./pictures/5%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/_-46679321__2dde1a912e0016f3162f3498ac095463_1951562707_Screenshot_20230803_164312_com.jideos_0_wifi_0.jpg" alt="_-46679321__2dde1a912e0016f3162f3498ac095463_1951562707_Screenshot_20230803_164312_com.jideos_0_wifi_0" style="zoom:50%;" />

### 二叉树的定义及其主要特征



### 二叉树的存储结构

1. 顺序存储

   完全二叉树和满二叉树存储比较合适，

2. 链式存储

   ```c++
   typedef struct BiTNode{
   	ELemType data;
   	struct BiTNode *lchild, *rchild;
   }BiTNode,*BiTree;
   ```

   引伸出三叉树





## 二叉树的遍历和线索二叉树

### 二叉树的遍历

- 前序编列

```c++
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);
		PreOrder(T->lchild);
		PreOrder(T->lchild);
	}
}

```



- 中序遍历

```c++
void InOrder(BiTree){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->lchild);
	}
}
```



- 后序遍历

```c++
void PostOrder(BiTree){
	if(T!=NUll){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```

- 递归算法和非递归算法的转换(需要借用==栈和循环==实现)

- 层次遍历(借助队列实现)

  在某结点出队时，将它的左右子结点入队。

```c++
void LevelOrder(BiTree){
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);
	while(!IsEmpty(Q)){
		DeQueue(Q,p);
		visit(p);
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);
		if(p->rchild!=NULL)
			EnQueue(Q,p->rchild);
	}
}
```



- 由遍历构造二叉树

  不论那种构造二叉树，都至少需要==两种==序列且其中一个必须是==中序==遍历。

  - 先序和中序
  - 后序和中序
  - 层序和中序







### 线索二叉树(二刷==注意==)

#### 线索二叉树的基本概念

在传统的树结构中，很难找到某结点的==双亲结点==，由此引出线索二叉树。

因为含$n$个结点的二叉树，有$n+1$个空指针。这些空指针可以利用起来存储信息。

```c++
typedef struct ThreadNode{
	ELemtype data;
	struct ThreadNode *lchild, *rchild;
	int ltag, rtag;
}
```



#### 中序线索二叉树的构造

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱和后继只有在遍历时才能得到，因此线索化的==实质==就是遍历一次二叉树

#### 中序线索二叉树的遍历

- 求中序线索二叉树的中序序列下的第一个结点

```c++
threadNode *Firstnode(ThreadNode *p){
	while(p->ltag==0) p=p->lchild;  //最左下结点(不一定是叶结点)
	return p;
}

```

- 求中序线索二叉树中结点p在中序序列下的后继

```
ThreadNode *Nextnode(ThreadNode *p){
	if(p->rtag==0) return Firstnode(p->rchild);
	else return p->rchild;
}
```

利用这两个算法，可以写出不含头结点的中序线索二叉树的中中序遍历算法

```c++
void Inorder(ThreadNode *T){
	for(threadNode *p=Firstnode(T);p!=NULL; p=Nextnode(p));
	visit(p);
}
```





#### 先序线索二叉树和后序线索二叉树

先序线索二叉树好像没啥特别的，但是后序线索二叉树因为需要找到跟结点的==右子树==，所以需要知道双亲结点，即需要带标志位的==三叉==链表

解题事项：多注意矛盾证伪，和递归的特性（栈)

## 树，森林

### 树的存储结构

也分为==顺序==存储和==链式==存储。

- 双亲表示法

  在连续空间中增设一个==伪指针==，指向其==双亲结点==在==数组==中的位置。

  其中，根结点的下标为`0`,其伪指针域(双亲结点)为`-1`

  ```c++
  #define MAX_TREE_SIZE 100
  typedef struct{
  	ElemType data;
  	int parent;
  }PTNode;
  typedef struct{
  	PTNode nodes[MAX_TREE_SIZE];
  	int n;
  }PTree;
  ```

  该存储结构利用了每个结点(除根结点)只有==唯一双亲==结点的性质，可以很快得到双亲，但求结点的孩子时则需要遍历整个结构。

  二叉树可以用树的存储结构存储，树==不能==用二叉树的存储结构存储。

- 孩子表示法

  将每一个孩子的孩子结点都用单链表链接起来，$n$个结点就有$n$个孩子列表。(叶结点的孩子链表为空表)

  这种结构寻找子结点很容易，寻找双亲结点需要遍历==每个==结点指向的链表。

  

- 孩子(==和==)兄弟表示法

  又称二叉树表示法，以二叉树作为树的存储结构。

  ```c++
  typedef struct CSnode{
  	ElemType data;
  	struct CSNode *fistchild, *nextsibling;
  }CSNOde, *CSTree;  //记录结点的第一个孩子，和结点自己的兄弟
  ```

  此方法最大的优点就是方便实现树==转化==为二叉树(因为存储在内存中的形式是一样的)，但查找双亲结点比较麻烦(可以通过增设一个`parent`域指向父结点)

  

### 树，森林与二叉树的转换

由于二叉树和树都可以用二叉链表作为存储结构，因此可以用二叉链表做为媒介导出树与二叉树的而==对应==关系。即给出一棵树，可以找到唯一的二叉树与之对应(从物理层面上看，存储都是相同的)

就是用==孩子兄弟表示法==

具体的转换方式：

树(森林)转化成二叉树

1. 在兄弟结点之间加一连线

2. 对每个结点，只保留它与第一个孩子的连线，其他的全部抹掉。

3. 以树根为轴心，==顺时针==旋转45度

   如果是森林则还需要一下步骤

4. 将每一个森林转化成的二叉树==根==连在一起

5. 以第一颗树的根作轴心==顺时针==旋转45度



二叉树转化成森林：

1. 若二叉树非空，将二叉树的==根及其左子树==作为第一颗树的二叉树形式，故将根的==右链==断开
2. 将右子树==递归==执行













### 树和森林的遍历

树的遍历(==没有中根遍历==)：

- 先根遍历

- 后根遍历

- 层次遍历

森林的遍历：

- 先序遍历

  类同于树的先序遍历，不过是依次遍历各颗树

  - 先访问森林中第一颗树的根节点
  - 先序遍历第一颗树中根节点的子树森林
  - 先序遍历出去第一颗树后剩余的树构成的森林

- 中序遍历

  - 中序遍历森林中第一颗树的根节点的子树森林
  - 访问第一颗树的根节点
  - 中序遍历除去第一颗树之后剩余的树构成的森林。

注意：

当森林转换成二叉树时，其==第一颗树==的子森林换成==左子树==，==剩余树==的森林转换成==右子树==。所以森林的==先序遍历==和==中序遍历==对应的就是二叉树的==先序遍历==和==中序遍历==

二叉树遍历的对应表

| 树       | 森林     | 二叉树   |
| -------- | -------- | -------- |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |

再次强调，==没有==中根遍历！！！

为什么：

因为 ：树有很多子结点，如果有所谓的中根遍历，那么同一个根结点就会被访问很多次





## 树与二叉树的应用

### 哈夫曼树和哈夫曼编码

#### 定义

树中结点如果被赋予某种有意义的值，那么我们称其为结点的==权==。

从树的根到 任意结点的路径长度(经过的边数)与该结点上权值的乘积，成为==带权路径长==

在含有$n$个带权叶结点的二叉树中，其中带权路径长==最小==的==二叉树==称为哈夫曼树



### 

#### 哈夫曼树的构造

- 将$n$个结点分别作为$n$颗==只==含有一个结点的二叉树
- 构造一个新结点，从$n$个结点中选取两个权值最小的树作为新树的左右结点，并将新树的权值==置为==左右两个子树的==权值和==
- 将使用过的结点去除
- 重复以上过程。



特点：

- ==每个==初始结点都将成==为叶结点==，且==权值越小==的结点到根结点的==路径越长==
- 构造过程中新建$n-1$个结点，因此哈夫曼树的结点总数为$2n-1$
- 哈夫曼树中不存在度为`1`的结点



#### 哈夫曼编码

`固定长度编码`

`可变长度编码`

`前缀编码`：没有一个编码是另一个编码的前缀(每一个编码都没与公共前缀)

前缀编码的优点：

- 无冗余
- 无歧义
- 即使编码间间紧密连接也不影响



### 并查集

本质上任然是一种==集合==

以下场景比较适用

- 在查询某结点是否==属于==某集合
- 生成两个集合的==并集==



1. 通常用==树的双亲表示==(查找双亲更加方便)用作并查集的存储结构，每个子集用一颗树表示。
2. 所有表示子集和的树，构成表示全集合的森林
3. 通常用==数组==元素的==下标==代表元素名，根结点的下标同时也代表==整个子集==，根的双亲结点为==负数==。

```
Initial(S)
Union(S,Root1,Root2)
Find(S,x)
```

