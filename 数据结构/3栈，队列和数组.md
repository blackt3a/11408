## 栈

#栈

### 栈的基本概念

#### 栈的定义

只允许在==一端==进行插入或删除操作的线性表。

- 栈顶

  线性表允许插入删除的那一端

- 栈底

  固定的那一端。

- 特

当$n$个元素进栈，出栈元素的排列组合个数是$\frac{1}{n+1}C_{2n}^{n}$（卡特兰数）

常考点：==合法==的出栈顺序。

#### 栈的基本操作

```c++
InitStack(&s)
StackEmpty(S)
Push(&S,x)
Pop(&S,&x)
GetTop(S,&X)
DestoryStack(&S)
```







### 栈的顺序存储结构

栈是一种受限的线性表，也就有线性表的两种存储方式。

- 顺序存储
- 链式存储

#### 顺序表的实现

采用顺序存储的栈称为顺序栈，利用一组==连续存储==的存储单元存放数据，同时设有一个==top指针==指示当前栈顶的位置。

```c++
#define MaxSize 50
typedef struct{
	Elemtype data[MaxSize];	//栈
	int top;				//栈顶指针
}SqStack;
```

- 栈顶指针S.top

  初始时设置S.top=-1;

  指向栈顶S.data[S.top]

- 入栈操作

  栈不满时(条件)，==先==栈顶指针==+1==（申请空位），再送值到栈顶位置

- 出栈操作

  栈非空时(条件)，先取栈顶元素，==再==栈顶指针==-1==

- 栈空条件

  `S.top`==`-1`

- 栈满条件

  `S.top`==`MaxSize-1`

- 栈长

  `S.top+1`




  注意栈溢出

  



#### 顺序栈的基本运算

- 初始化

```c++
void InitStack(SqStack &S){
	S.top=-1
}
```

-   栈判空

```c++
bool StackEmpty(SqStack S){
	if(S.top==-1)			//安全检查
		return true;
	else
		return false;
}
```

-   进栈

```c++
bool Push(SqStack &S,ElemType){
	if(S.top==MaxSize-1)   //先检查
		return false;
	S.data[++S.top]==x;		//先申请位置
	return true;
}
```

-   出栈

```c++
bool Pop(SqStack &S,ElemType &x){
	if(S.top==MaxSize-1)
		return false;
	S.data[++S.top]=x;
	return true;
}
```

- 读栈顶

```c++
bool GetTop(SqStack S,ElemType &x){
	if(S.top==-1)		//安全检查
		return false;
	x=S.data[S.top];	//读元素，但并没有弹出
	return true;
}
```

####   

#### 共享栈

利用栈底相对不变的特性，可以让两个顺序栈==共享==同一个一维数组空间，两个栈的==栈底==在==两边==。

共享栈动态调节两个栈的空间，更有效地利用了==存储==空间，只有在整个空间被占满时才会溢出(但是，此时溢出和不溢出已经没什么区别了)。

对==存取==效率没有影响。时间复杂度都是$O(1)$    ![](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/_fd989fcc8d6124face1027bce14ef179_-1110178717_Screenshot_20230730_154938_com.jideos.jnotes) 

### 栈的链式存储

- 采用链式存储的栈称为链栈，便于多个栈==共享==内存空间和提高==效率==。

- ==不会==存在上溢。
- 通常采用单链表实现。（需要注意的是，对于带结点和不带结点的链栈，实现会==不同==）





## 队列

### 队列的基本概念

- #### 队列的定义

  :one:队列(Queue)，也是一种操作受限的线性表，只允许在一端进行插入(入队)，在另一端进行删除(出队)

  :two:先进先出,==没有==所谓合法出队组合。

- 队列的常见操作

```c++
InitQueue(&Q)
QueueEmpty(Q)
EnQueue(&Q,&x)
DeQueue(&Q,&x)
GetHead(Q,&x)
```

注意：栈和队列都是受限的线性表，所以==不能==随意读取中间的数据



### 队列的顺序存储结构

#### 队列的顺序存储

队列的==顺序实现==是指分配一块==连续==的存储单元存放队列中的元素。并设==两个指针==。

- 头指针指向队头元素
- 尾指针指向队尾元素的==下一个==位置(具体的定义可能随环境不同而不同)

```c++
#define MaxSize 50
typedef struct{
	ElemType data[MaxSize];		//队列空间
	int front,rear				//头尾指针
}
```

- 初始时 ，`Q.front`=`Q.rear`

  ![_-1915560433__7a6e6152dbf11af568f14851cab607f9_897780476_Screenshot_20230730_223109_com.jideos_0_wifi_0](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/_-1915560433__7a6e6152dbf11af568f14851cab607f9_897780476_Screenshot_20230730_223109_com.jideos_0_wifi_0-1690727611074-6.jpg)

- 入队时，先将值送入队，再将==队尾==指针`+1`

  除非顺序队列为空，尾指针都指向插入元素的==后一个==位置

  ![_-406998571__45f0af8de4150287808507ae4baff571_-1725761992_Screenshot_20230730_223127_com.jideos_0_wifi_0](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/_-406998571__45f0af8de4150287808507ae4baff571_-1725761992_Screenshot_20230730_223127_com.jideos_0_wifi_0-1690727627959-9.jpg)

- 出队时，先取队头值，再将==队头==指针`+1`

  ![_1007859843__743d57d4855451ca6808f9094265d691_2011322558_Screenshot_20230730_223408_com.jideos_0_wifi_0](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/_1007859843__743d57d4855451ca6808f9094265d691_2011322558_Screenshot_20230730_223408_com.jideos_0_wifi_0-1690727744430-15.jpg)

  

![这里写图片描述](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/70.png)





==想一想==为什么和栈不一样？(仅限顺序队列)

栈先移动指针，再数据操作。

队列先操作数据在移动指针。

答：

队列的队尾指针(空间足够时)都是指向==待写==入的空白位置。可以先写再移动指针指向下一个待写位置。

栈的指针都是指向栈顶元素(已写入)，必须先移动再写入，否则栈顶将被==覆盖==。



==注意==：

- 在队列的顺序存储中，可以用`Q.front==Q.rear==0`（即队头和队尾指针都指向空),，此时可以作为队列==判空==条件。
- `Q.rear==MaxSize`不能作为==队满==的判别条件(当队列中==还有==一个元素时，也是符合的)
- 注意==顺序实现==队列的“假溢出现象”(顺序实现队列的特有现象)













#### 循环队列

为了==解决==顺序实现队列的缺点(假溢出)，引出了==循环队列==。（逻辑上是环状的，但存储时依旧是顺序的)。利用除法==取余==实现。

- 初始 `Q.front`=`Q.rear`=`0` （和普通列表一样)

- 队首指针进`1`后取余数 `Q.front`=`(Q.front+1)%MaxSize`

- 队尾指针进`1`后取余数 `Q.rear`=`(Q.rear+1)%MaxSize`

- 队列长度：`(Q.rear+Maxsize-Q.front)%MaxSize`

  `rear+front+MaxSize`的原因：

  虽然，循环队列在逻辑上实现了循环，但是终究受限于线性存储的物理限制，当队满后，队列出队一些元素，再入队一些元素(解决了假溢出)。此时`Q.rear<Q.front`,为了不让其为负数造成真正的数组越界，所以取余数。

  ![_-852862926__a391ce69b21f46042e5fa518fd259b03_-1030777188_Screenshot_20230730_225859_com.jideos_0_wifi_0](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/_-852862926__a391ce69b21f46042e5fa518fd259b03_-1030777188_Screenshot_20230730_225859_com.jideos_0_wifi_0-1690729220152-18.jpg)

出队入队时，指针==都==按同一个方向进`1`然后取余数。

- 队空判断：`Q.front=Q.rear`

- 队满判断容易产生歧义，即队空队满都是`Q.front=Q.rear`所以有以下三种处理方式：

  - 牺牲一个存储单元，用来==区分==队空队满。入队时，少用一个。队满时是`Q.front-1=Q.rear`(普遍的做法)。

  - 增加一个变量记录元素==个数==。

    若`Q.size=MaxSize`则队满。

    若`Q.size=0`则队空。

  - 增加一个`tag`变量区分队空队满。

    `tag=0`时，如果是因为删除导致`Q.front=Q.rear`则为队空。

    `tag=1`时，如果是因为入队导致`Q.front=Q.rear`则为队满。



##### 循环队列的操作

- 初始化

```c++
void InitQueue(SqQueue &Q){
	Q.rear=Q.front=0;
}
```

- 判队空

```c++
bool isEmpty(SqQueue Q){
	if(Q.rear==Q.front) then true;
	else return false;
}
```

- 入队

```c++
bool EnQueue(Squeue &Q,ElemType x){
	if((Q.rear+1)%MaxSize==Q.front) return false;
	Q.data[Q.rear]=x;
	Q.rear=(Q.rear+1)%MaxSize;
	return true;
}
```

- 出队

```c++
bool DeQueue(SqQueue &Q,ElemType &x){
	if(Q.rear==Q.front) return false;
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
	return true;
}
```



### 队列的的链式存储结构

#### 队列的链式存储

队列的链式表示称为链队列，实际上就是一个同时带有==队头==指针(头结点)和==队尾==指针(尾结点)的单链表。

尾指针指向的是链表的==后驱==方向。

```c++
typedef struct LinkNode{
	ElemType datda;
	struct LinkNode *next;
}LinkNode;				//结点

typedef struct{
	LinkNode *front,*rear;
}*LinkQueue;			//队列
```

- 判空 `Q.front=Q.rear=NULL`

- 出队 

  先判断队列是否为空，若不尾空，取出队头元素，将其从链表中取出，并让`Q.front`指向下一个结点。此时如果没有了结点则将`Q.front`和`Q.rear`都指向`NULL`

- 入队

  建立一个新结点，将新结点插入到链表尾部，并让`Q.rear`指向新插入的结点，若原队列为空，则此时`Q.front`也指向该结点。

tips：

- 将队列视作操作==受限==的线性表(此时尾链表)，可能更好理解些。
- 当队空时==和==队列中只有一个元素时，`Q.front=Q.rear`,
- 不带头结点的链式队列会操作会比较麻烦，所以一般设计成一个带==有头结点==的单链表

#### 链式队列的基本操作

- 初始化

```c++
void InitQueue(LinkQueue &Q){
	Q.front=Q.rear=(LinkNode *)malloc(sizeof(LinkNode));
	Q.front->next=NULL;
}
```

- 队列判空

```c++
bool IsEmpty(LinkQueue Q){
	if(Q.front==Q.rear) return true;
	else 
		return false;
}
```

- 入队

```c++
void EnQueue(LinkQueue &Q,ElemType x){
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;s->next=NULL;
	Q.rear->next=s;
	Q.rear;
}
```

- 出队

```c++
bool DeQueue(LinkQueue &Q,ElemType &x){
	if(Q.front==Q.rear) return false;
	LinkNode *p=Q.front->next;
	x=p->data;
	Q.front->next=p->next;
	if(Q.rear==p)
		Q.rear=Q.front;
	free(p)
	return false;
}
```













### 双端队列

定义

:one:双端队列两端都可以进行入队和出队操作的队列。

:two:其元素的逻辑结构仍是线性结构。

:three:将队列的两端分别称为前端和后端

两端==都可以==入队和出队。也即双端队列==同时==具有队列和栈的特征。

特性

- 双端队列(完全态)

  两边都可以入队和出队

- 受限的双端队列

  - 输入受限的双端队列

    允许一端进行插入和删除，另一端只允许==删除==(少一个输入)

  - 输出受限的双端队列

    允许一端进行插入和删除，另一端只允许==插入==(少一个输出)

  - 蜕化为==同底相邻栈==的双端队列

    队同一个点的操作(入队和出队)只能在队列的一端，即底相同的方向不同的栈。





## 栈和队列的应用

### 栈在括号匹配中的应用

在字符匹配中，可以使用栈来匹配括号

1. 设置一个空栈，==顺==序读入括号
2. 如果是右括号，就==弹出==栈顶的左括号(栈顶不匹配则退出)
3. 如果是左括号，则压==入栈==。
4. 匹配结束时，要求==栈空==。





### 栈在表达式求值中的应用

表达式求值分为三种：

- 前缀表达式(很少)

  右优先

- 中缀表达式(日常)







- 后缀表达式(重点)

  在后缀表达式的转换过程中，往往同一个表达式可能会有多个结果(不符合函数的唯一性原则)，所以我们常在后缀表达式中采用==左优先==原则。

  实现：

  1. 初始化一个符号栈`S`和一个临时列表`L`

  2. 从左到右遍历中缀表达式的每个字符。

  3. 如果是==操作数==，则直接添加到`L`的末尾。

  4. 如果是运算符：此时==栈空==或当前元素为`（`，直接入栈。

     是否是`)`:?

     :o:==重复弹出==`S`栈顶运算符到`L`,直到遇到`(` ,`（`不进`L)`。因为中缀表达式是没有括号的。

     :x:当前运算符是否==大于==栈顶元素：？

     ​	:o:当前元素进栈

     ​	:x:==弹出==`S`栈顶到`L`，并将当前元素也弹到`L`

     ![image-20230731210107908](./pictures/3%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.assets/image-20230731210107908.png)

     

     

     

     

     

     

     







### 栈在递归中的应用

递归在程序设计中非常重要。

- 定义：

  简单地说，如果程序在执行过程中，调用了==自身==，则可以说这个函数是递归定义的。

- 特点：

  - 将一个大型复杂的问题转化为与原问题相似的规模较小的问题求解。
  - 只需少量代码就可以描述解题所需要的多次运算。较少了代码量。
  - 通常效率不高

- 必须满足的条件：

  - 递归==表达式==(递归体)
  - 边界条件(递归==出口==)

- 注意：

  - 递归和循环不一样。
  - 递归的==精髓==就在于是否能将原始问题转化为属性相同但规模更小的问题。
  - 可以利用==栈==，将递归转化为非递归。







### 队列在层次遍历中的应用

树(森林，二叉树)中的层次遍历，广度优先遍历。

1. 根节点入队
2. 若队空(所有节点已处理完毕)，则结束遍历。否则第三步
3. 队列中第一个结点出队(访问)，将出队节点左右孩子依次入队。再次执行第二步。

==注意==：先出队，再入队

### 队列在计算机系统中的应用

- 解决主机与外部设备之间不匹配的问题

  设置一个缓冲区，缓冲区中数据就是队列。

- 多用户引起的资源竞争问题

  主机按照请求时间的先后循序，把他们排成一个队列。