
#进程的概念特征 

进程映像（程序）是静止的，进程是动态的。


定义：
- 程序的一次==执行==过程
- 程序及数据在处理机上==顺序==执行时所发生的活动
- 独立功能程序在数据集合上运行的过程，资源分配与调度的==独立==单位

进程的特征：
- 动态性
- 并发性
- 独立性
- 异步性

进程状态的切换（五状态形式）：
- 运行态
- 就绪态
- 阻塞态
- 创建态
- 终止态

注意：
 - 阻塞态和就绪态的区别是----就绪态缺少的是==CPU==资源，而阻塞态缺少的除了CPU之外的==其他==资源（IO等）。
 - 运行态便阻塞态是主动的，阻塞态到就绪态是被动（需要协助）

#PCB
PCB是进程存在的==唯一==标志!!!

作用：
- 描述进程信息（状态，优先级，程序段，数据段等）
- 进程控制和管理信息
- 资源分配清单
- 处理机相关信息

PCB的组织形式：
			- 链表
			- 索引

#进程控制 

进程控制是由==原语==执行（不可打断）

进程创建：
- 1分配进程表示号，并分配空白PCB
- 2请求相关资源
- 3初始化PCB（标志信息，处理机状态，优先级）
- 4放入等待队列知道被调度
进程由父进程创建，父进程被撤销，所有子进程也会被撤销;子进程被撤销，所有资源会被返回给父进程。


进程终止：
- 1根据标识符得到PCB,读进程状态
- 2若是运行态，立即终止，分配资源给其他进程
- 子孙进程终止
- 进程资源返还父进程或操作系统
- 删除PCB节点

进程的阻塞与唤醒：
- 阻塞（是一种主动行为，所以只有运行态获得CPU的进程）
	- 1找到标识号对应的PCB
	- 2若为运行态，保护好现场，将其转为阻塞态，停止运行
	- 3将PCB插入等待队列

- 唤醒（需要协助）
	- 在该事件的等待队列中找到相应的PCB
	- 将其从等待队列中移除，设置状态为就绪态。
	- 把PCB插入就绪态，等待调度程序调度。


#进程间通信 
- 1 共享存储
	- 低级共享：基于数据结构的共享（低效）
	- 高级共享：基于存储区的共享

- 2消息传递
	以格式化的消息为单位（若不能以共享的方式通信，就用消息传递）
	- 直接通信方式：直接发送消息到==指定==进程的缓冲区
	- 间接通信方式：将消息发送到某中间实体（信箱）

- 3管道通信
	管道机制必须实现:互斥,同步,确认对方的存在.
	- 管道是一个==固定==大小的缓冲区，单一方向（一边只能写，一边只能读，有数据就能读）
	- 管道只能由创建进程访问（读,且读一般比写快），若要双向通信，需实现两个管道.
	

#线程的基本概念 
为了更好地实现==并发==,提高系统资源利用效率,减少时空开销而引出.
线程理解为==轻量级进程==,==基本的CPU执行单元==.
线程不拥有==系统资源==
线程可以由==另一个==线程创建或撤销
线程有==就绪==,==阻塞==,==运行==三种状态.

#线程与进程的区别
进程是除CPU以外的系统资源的分配单元
线程是处理机(CPU)的分配单元.

线程与进程的比较:
   - 调度(调度单元变化)
   - 并发性(效率更高)
   - 拥有资源(线程只拥有必要的资源)
   - 独立性(进程内共享)
   - 系统开销(减少上下文切换)
   - 支持多处理系统(多个线程可以在多个处理机上运行)

#线程的属性 
- 1线程是一个轻型实体,拥有线程控制快(TCB)
- 2不同线程可执行相同程序(不同用户执行性,被认为是不同的线程)
- 3进程内线程共享资源
- 4线程是独立调度的单位.
- 5有就绪态,运行态,阻塞态等状态变化.

线程的状态与转换:
- 就绪态
- 执行态
- 阻塞态


线程的组织与控制:
- 线程控制块(TCB)
		- 线程表示符
		- 寄存器组
		- 线程运行状态
		- 优先级
		- 线程专属存储区
		- 堆栈指针
- 线程的创建
		- 申请TCB,初始化等
- 线程的终止
		- 通常,线程被终止以后不立即释放它占有的所有资源,只有当其他线程执行了分离函数后,被终止线程才与资源分离.
		- 被终止但未释放资源的线程仍然可以被其他线程调用,以使被终止线程重新恢复运行.


线程的实现方式
- 用户级线程
		- 线程切换不需要到内核空间,节省开销(用户线程是用户空间调用)
		- 调度算法进程专用
		- 线程实现与系统无关
	 - 但不能发挥处理机优势
	 - 一个线程阻塞,整个进程也阻塞.
- 内核级线程
	- 发挥处理机优势(内核线程是对内核空间的调用)
	- 线程状态不影响其他线程
	- 数据需求小,相比进程切换,开销小
	- 内核本身也可以采用多线程技术.
- 组合方式
	- 一对一
		-线程管理在用户空间上,效率高
		-一个线程阻塞就都阻塞,内核视角只是一个进程(线程)
	- 多对一
		-并发能力强
		-一个用户线程对应一个内核线程,开销巨大
	- 多对多
		-组合两者优点


#进程和进程映像
进程实体包含进程映像没有的==数据==

#辨析
- 某一时刻可能因为==死锁==,==循环等待==或其他系统中没有运行态进程.
- 封闭性是指,程序在输入一致时,结果一致,不遂其他原因(==运行速度==)改变
- 多线程(多核)好处:
	- 在于提升系统效率,提高并发效率(对于系统而言)
	- 提高交互体验(对于用户而言)
- 内核线程中运行的是内核程序,提高的是==内核==调度效率
- 对于时钟中断对进程(线程)切换的影响:
	- 先发生时钟中断,再对PCB(TCB)进行检测,然后再考虑是否切换.
	- 难不成还能反着来.

#处理机调度 

#处理机调度的概念
处理机调度是多道程序操作系的基础

#处理机调度的层次
- 1高级调度(作业调度,频率最少)
		- 从==外存==中挑选处于后备队列的作业,是内存与外存之间的调度,每个作业只调入调出一次.
- 2中级调度(内存调度,频率居中)
		- 目的是提高内存的利用率和系统的吞吐量,将==挂起==的进程调至外存等待
- 3低级调度(进程调度,频率最高)
		- 必须配置的==最基本==的调度,从==就绪==队列中选取.
	三级调度之间的联系:
	作业调度从后备队列中选(==创建==进程)
	内存调度是为了提高内存的==利用率==
	进程调度是从就绪队列中选取,分配==CPU==给它


#调度的目标 
需要考虑的目标:
	- CPU利用率 = 工作时间/(工作时间+等待时间)
	- 系统吞吐量 = 单位时间完成作业==数量==
	- 周转时间    =  作业从==提交==到完成的时间
	- 等待时间    =  等待的总时间
	- 响应时间    =  从提交到==首次==响应


#调度的实现

#调度程序
用于调度和分派CPU的组件成为调度程序,分为==排队器==,==分派器==,==上下文切换器==

#调度的切换时机与过程
==不能==进行调度的时机:
- 处理中断的过程中()
	-==递归==中断将会比较麻烦.
- 进程在操作系统的临界区中（可以，但是不能对数据造成影响，可以读）
	-在进程占用系统临界区资源时调度可能使临界区资源被==锁定==.
- 其他需要完全屏蔽中断的源自操作中
	-加锁,解锁,中断现场的保护与恢复(这些都是原子操作)等


#进程的调度方式
大体可以分为抢占式和非抢占式
- 非抢占式
	- 适用于大多数的==批处理==系统(因为简单,消耗低),不适用==分时==系统(对交互有要求)和==实时==系统(对响应有硬性要求)
- 抢占式
	- 当有更==重要==或更==紧急==(两者意义不同)的进程需要处理.根据一定==原则==(非任意)处理.
	- 其对提高吞吐率和响应效率有好处,原则依凭==优先权==,==时间片==,进程运行==预期==

#闲逛进程
当系统没有==就绪j==进程时,系统调用==闲逛==进程.
闲逛进程的优先级==最低==,在执行过程中也只是==测试==中断.
只占用CPU,所以不会被阻塞


关于用户线程与内核线程的调度
- 内核是不知道用户线程的存在(在它看来是进程),所以有它所在的进程决定(在线程切换时往往效率高,消耗低)
- 内核线程调度时,不考虑是那一个进程(在线程切换时往往效率低,消耗高)


#典型的调度算法
- 先来先到(FCFS)
	调度只参考==就绪==队列,属于不可抢占算法(不能用于==分时==和==实时==系统)
	 - 缺点:
		 - 效率低
	- 优点:
		- 简单
		
	- 特点:
		不抢占
		对==长作业==有利(对短作业不利),有利于CPU繁忙型(不利于IO繁忙型，一但IO就重新排队。)


- 短作业优先(SJF)
  调度原则参考的是就绪队列中任务运行的==预估==时间
	- 优点:
		- SJF的==平均等待==时间和==平均周转==时间==最少==(对==操作系统==有利)
		- 比FCFS好,也只比FCFS好.
	- 缺点:
		- 完全没考虑用户{任务}的紧迫型
		- 对长作业不利,可能被饿死
		- 如果用户假装自己运行时间很少,可以获得优先
	- 特点:
		- 不抢占
		- 也只好一点.
	
- 优先级调度算法
	- 抢占式优先:
		因为进程==结束==或==阻塞==会将CPU让给==就绪==队列中优先级最高的进程
		如果不是,该运行还是运行.
	- 非抢占式优先:
		如果就绪队列中有一个优先级跟高的进程(即使和当前进程相比),当即进行进程切换(才不管他是不是真的在上厕所).
		
		优先级又可以分为==静态==优先级和==动态==优先级
						- 静态优先级：在进程建立时确立。
						- 动态优先级：在进程运行中变化。
			优先级的静态(动态)与是否可抢占==没关系==
	- 一般来说：
		- 系统进程 > 用户进程
		- 交互型进程 > 非交互型进程
		- IO型进程 > CPU型进程（IO慢，让IO尽早工作可以提高系统整体效率）
		

- 高响应比优先调度算法
	高响应比优先算法主要用于==作业==调度
	是对FCFS和SJF的一种==平衡==,同时考虑==等待==时间和==运行==时间.
	
	==响应比== =(等待+预期)/预期
	
	选取响应比==最大==的等待进程.
	特点:
	- 等待时间相同时,预期运行时间越短,响应比越大,有利与==短作业==(想SJF)
	- 预期运行时间相同,等待时间越长,响应比越大(等的时间越久优先级越大,像FCFS)
	- 都能执行,避免了饿死

- 时间按片轮转算法:
	主要适用与==分时==系统
	进程按==FCFS==策略,轮流使用规定的时间片,时间片用完重新排队.
	特点:
	  系统性能受时间片的==划分==影响非常大.
	- 时间片很大,就很像(退化)FCFS
	- 时间很小,就将频繁切换,导致效率降低.



- 多级队列算法:
	将任务的类型和性质划分到多个(就绪)队列,可以每个进程实施==不同==调度算法(优先级也可以不同)
	特点:
	- 有想法,只是一个过渡


- 多级反馈队列调度算法(究极缝合怪)
	- 算法过程:
		- 1设置多个==就绪==队列,每个队列不同优先级(1级最高,2级次之....)
			-任务刚开始时,投入第一级(优先级最高)
		- 2每个队列的时间各==不相同==
			-优先级越高的队列时间片==越短==.
		- 3每个队列采用==FCFS==调度算法:
			-任务在一级的时间片用完以后,转到二极(==尾部==),然后是三级(尾部).
		- 4按==队列==优先级调度
			-在一级队列的==所有==任务结束后才开始二极
	 - 特点:
		 - 对终端用户而言,==短作业==优先(交互好)
		 - 批处理短作业用户,==周转==时间短
		 - 批处理长作业用户,也==能执行==,不会被饿死(长作业永远都是最惨的.QAQ)



#进程切换 
进程切换由内核完成

#上下文切换
- 挂起进程
- 保存CPU信息(PC,SP)到PCB
- 将PCB移入相应队列(就绪,阻塞)
- ==选择==一个进程,更新PCB
- 跳转到新进程(将PC指向PCD保存的地址)

#上下文切换的消耗
非常消耗才CPU时间
但提供多个寄存器组可以减缓


#上下文切换与内核切换的区别
上下文切换只会存在内核态(进程控制)
(内核)模式是从用户态到内核态(也可能是返回),并没有改变==当前==进程(描述得也不是很准确),仍然是同一个进程.

注意：切换和调度不同
- 调度是一种==决策==（商议）
- 切换是一个动作
一边来说，先有资源调度，再有切换。





#同步与互斥 

#同步与互斥的概念 
使进程在调度的同时不失去封闭性（运行结果不变）

注意：并发==原生==带有异步性，所以需要对进程同步


#临界资源
共享系统中一次只能被==一个==进程使用的资源，比如打印机，==公用队列==
然而：==磁盘==属于共享设备，不是临界区资源。

对临界资源的访问必须==互斥==进行
对临界资源访问的代码称为==临界区==

注意：
- 一个进程映像由程序，数据，PCB组成。映像中程序又分为==共享==和==非共享==
- 一定要注意辨析==临界区与==（代码）与==临界区资源==（数据）。由此，多个进程可能有==多个==相同的临界区，但是临界区资源只有==一个==（如果有同步互斥关系）



访问步骤：
- 进入区
- 临界区（操作）
- 退出区
- 剩余区


辨析：
	- 进入临界区与占用CPU没有必然关系，进程可以占用CPU执行==非临界==区代码，但确定的临界区一次只能有一个进程进入。


#同步 
==直接==制约关系


#互斥 
==间接==制约关系


#同步原则
- 空闲让进
- 忙则等待
- 有限等待（不能等太久）
- 让权等待（该让就让，只有“==信号量==”实现）



#临界区互斥的基本方法

#软件实现方法 
- 单标志法
	- 必须使两个进程交替进入临界区才能正常运行，不然就卡死给你看
	- 违背“==空闲让进==”
- 双标志（先检查）
	- 不足：检查和操作不能==一次==执行完，可能是两个进程==同时==进入临界区
	- 违背”==忙则等待==“
- 双标志（后检查）
	- 不足：两个进程在表明“想要”，可能相互谦让（导致==饥饿==）
	-
- Person算法
	- 比较综合地解决问题。
	- 但没有解决==让权等待==的问题（好像也不是一定要解决）



#硬件实现方法 
- 中断屏蔽法
利用关中断实现
注意：关中断期间，其他进程是无法打断该进程并修改数据，在同步时需非常注意`while（ture）`可能造成的死循环。

硬件指令法
- TestAndSet（原子操作）
==读出==指定标志后设置为==真==
- Swap指令
交换两个标志


优点：
- 适应任何数量的进程。
- 对但处理机和多处理机都支持
- 支持同一进程有多个临界区（只需为每个临界区设置一个布尔变量）

缺点： 
- 都比较消耗性能（处理机时间），
- 不能实现==让权等待==
- 可能使部分进程“饿死”（在进程等待队列中，它是随机选一个）



#互斥锁
缺点：容易造成==忙等待==



#信号量
wait---P
signal--V
通常由硬件实现


- 整形信号量
	-用一个整型代表资源数
- 记录型信号量
	-用一个整型代表资源数
	-用一个==队列==表示所有等待该资源的进程
- 利用信号量实现同步
	- 在“前操作”之后执行V
	- 在”后操作“之前执行P

- 利用信号量实现互斥
	互斥的信号量一般是<=1.  (一次只允许一个进程访问，但是可以有多个等待)

tips：如果一个进程唤醒另一个==阻塞==的进程，说明由原来信号量S为==负数==


#分析进程同步和互斥的方法步骤 
- 关系分析
- 整理思路
- 设置信号量


#管程
为了防止手动操作不当造成死锁的进程同步工具（对象思想）
可以实现进程间的互斥和同步。
一次只能有一个进程进程进入管程

组成：
- 管程==名称==
- 管程内部共享==数据结构==的说明
- 对共享数据的==操作==
- 设置共享数据==初始值==

条件变量：
- wait()
	-当资源不足时才调用wait()，调用wait()的进程将把必定自己插入==阻塞==队列
- signal()
	-归还一个资源，唤醒一个因为x而阻塞的进程。

```
monitor Demo{
	condition x;
	init_code() {....}
	take_away(){
		if(s<=0) x.wait(); 
	}

	give_back(){
		if(有等待的进程) x.signal(); //唤醒一个阻塞的
	}

}
```






注意：
- 管程中的signal()操作和信号量中的V是不同的，V是一个单一动作;signal()除了动作还包含了==判断==
- 管程中，wait()操作是不会改变资源技术器的，这是==两个==不同的部分。


#经典同步问题
- 生产者-消费者问题
- 读者-写者问题
- 哲学家进餐问题 
	- 仅当获得左右筷子后进餐
	- 奇数哲学家获得左边筷子，偶数哲学家获得右边筷子
	- 最多n-1名哲学家同时进餐





#死锁
死锁的定义：多个进程因竞争资源而造成的僵局（互相等待）

死锁产生的原因：
- 系统资源的竞争（只有对==不可剥夺==的资源进行竞争才可能造成死锁）
- 进程推进顺序非法（对信号量的使用不当也会造成死锁）

即==时间==与==空间==的

死锁产生的必要条件（必须同时满足）：
- 互斥条件
- 不剥夺条件
- 请求并保持条件（已经有部分资源，又提出新的请求）
- 循环等待
	- 死锁必定是==因为==循环等待，但循环等待不一定造成死锁。当已有的资源大于请求的资源时，即使循环等待也不会死锁。

不严格地说，死锁就是==资源不足==时又相互（循环）等待（请求）



死锁的处理策略：
- 死锁预防（破坏4个必要条件之一，使必不可能产生死锁）
	- 破坏互斥条件
		-不从这个方向入手。
	- 破坏不可剥夺条件
		-释放某一个等待进程
	- 破坏请求并保持条件
		-所需资源一次申请完（会造成浪费）
	- 破坏循环等待条件
		-给每个资源标号，用==顺序资源分配法==
		
- 避免死锁（有可能产生，但尽力阻止）
	- 系统安全态
		-当按某个特定队列推进进程时（前提），不会死锁就是安全态
		-不是所有不安全状态都会造成死锁（只是有可能）
	- 银行家算法
		-检查资源
		-尝试分配
		-安全检查


- 死锁的检测与恢复（发生死锁后解除）
	- 资源分配图
	- 死锁定理
		-检测是否为死锁状态
	- 死锁解除
		-资源剥夺
			通常不会从非死锁进程抢夺资源
		-撤销进程
		-进程回退

回退：某资源一分钟前拥有某资源，释放资源后，回退又将拥有资源